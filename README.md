
Макет системы поиска по содержанию текстовых документов.
========================================================

Введение.
---------

  Перед  вами  локальный   полнотекстовый   поисковик,   некоторая   пародия  на
Яндекс  или  Гугл,  но  только  работающий  полностью  локально и представляющий
собой  единый  модуль,  который  можно,  например,  интегрировать  в  какую-либо
другую  программу  или  программный  комплекс,  нуждающийся  в подобной функции.
Собственно,  для  этого  он  и  был  написан. Также, разумеется, преследовался и
некоторый  исследовательский  интерес:  как  же  там  в  Яндексе  всё работает и
ищется.

Системные требования.
---------------------

1. C++17 (STL)
2. GCC 11.2.0 (проверена работоспособность для Linux Mint 20.03 с установленными
пакетами gcc и MinGW-w64 9.0.0 Windows7_x86) или Visual Studio 2019+.
3. CMake 3.18.0

Компиляция и сборка проекта.
----------------------------

  Сборка проекта возможна  с  применением  любого  компилятора  C++  17. В целях
облегчения  сборки  к  проекту  приложены  сборочный  cmake-скрипт и уже готовый
проект   для  ИСР  CodeBlocks.  Каких-либо  внешних  нестандартных  зависимостей
проект не имеет.

Использование.
--------------

  Способ  работы с этим поисковиком  продемонстрирован   в   файле main.cpp, где
также содержатся некоторые модульные тесты. Более  детально внешний  программный
интерфейс  поискового  модуля,  который  предстоит использовать подключающей его
программе, описан в этом документе далее.

Интерфейс программы, способы и приёмы работы с ней.
---------------------------------------------------

  В  целом  весь   процесс   работы  с  поисковиком  распадается  на  три  фазы:
создание   поискового  объекта  (объекта  класса  SearchServer)  в  сочетании  с
его  предварительной  настройкой,  регистрация  документов  в  поисковом объекте
(метод   AddDocument)   и,  собственно,  поиск  документов  по  запросам  (метод
FindTopDocuments).

  Кроме  того,  поисковик   предоставляет   некоторый   дополнительный   сервис:
матчировка   зарегистрированного   документа   -   проверка   соответствия   его
запросу,   удаление   документов   из  базы,  разбиение  результатов  поиска  на
страницы.

####   Сокращенное,  иллюстративное  объявление  класса  SearchServer  со  всеми
доступными публичными методами приведено ниже:

    class SearchServer
    {
        SearchServer(string_view stop_words, int result_document_count = DEFAULT_DOCUMENT_COUNT);
        //-------------------
        void AddDocument(int document_id, std::string_view document, DocumentStatus status,
                                       const std::vector<int>& ratings);
        //-------------------
        std::vector<Document> FindTopDocuments(const std::string_view raw_query, DocumentStatus demand_status = DocumentStatus::ACTUAL) const;
        std::vector<Document> FindTopDocuments(const std::string_view raw_query, FilterPred filter_pred) const;
        std::vector<Document> FindTopDocuments(ExecutionPolicy&& policy, const std::string_view raw_query, DocumentStatus demand_status = DocumentStatus::ACTUAL) const;
        std::vector<Document> FindTopDocuments(ExecutionPolicy&& policy, const std::string_view raw_query, FilterPred filter_pred) const;
        //-------------------
        int GetDocumentCount() const;
        void RemoveDocument(int document_id);
        int GetSetResultDocumentCount(int new_result_document_count) const;
        //-------------------
        tuple<vector<string_view>, DocumentStatus> MatchDocument(string_view raw_query, int document_id) const;
        tuple<vector<string_view>, DocumentStatus> MatchDocument(_ExecutionPolicy&& policy, const string_view raw_query, int document_id) const;
        //-------------------
        int size() const;
        iterator begin() const;
        iterator end() const;
    };

### Первый этап.

  Итак,   создание   поискового   сервера   выполняется   созданием   переменной
класса   SearchServer,   конструктору   которого   может   быть   передано   два
аргумента   -   список   стоп-слов   и   максимальное  количество  документов  в
выдаче.    Стоп-слова   -   слова   документов   и   запросов,   которые   будут
игнорироваться при поиске.

    SearchServer srch("and at with"s, 5);

  Этой  декларацией  создаётся   поисковый   сервер   srch  с  набором  из  трёх
стоп-слов  (and,  at,  with)  и  максимальным  количеством  документов в выдаче,
равным 5.

### Второй этап.

Регистрация документов выполняется вызовом метода AddDocument класса SearchServer.

1.  Первый аргумент - условный номер документа, может выбираться произвольно, но
у каждого документа должен быть уникальным.

2. Второй аргумент - собственно, текст самого документа.

3. Третий  аргумент  -  статус  документа,  который   может  использоваться  как
дополнительный признак фильтрации при поиске документа.
Выбирается из следующего перечисления:

        enum class DocumentStatus
        {
            ACTUAL,
            IRRELEVANT,
            BANNED,
            REMOVED
        };

4. Наконец,   четвёртый   параметр   -  массив   рейтингов   документа,  который
служит  дополнительным  параметром  сортировки  документов  в  поисковой выдаче,
если  параметры  релевантности  документов  запросу  равны.  Представляет  собой
массив  целых  чисел,  для  которых  внутри  сервера  будет  рассчитано  среднее
арифметическое,    усечённое    до    целого    значения,    которое   и   будет
использоваться при сортировке.

Серией вызовов

    search_server.AddDocument(1, "nasty dog with big eyes"sv, DocumentStatus::ACTUAL, {1, 2});
    search_server.AddDocument(2, "funny pet and nasty rat"sv,  DocumentStatus::ACTUAL, {1, 2});
    search_server.AddDocument(3, "funny pet with curly hairs"sv,  DocumentStatus::ACTUAL, {1, 2});
    search_server.AddDocument(4, "funny pet and not very nasty rat"sv,  DocumentStatus::ACTUAL, {1, 2});
    search_server.AddDocument(5, "pet with rat and rat and rat"sv,  DocumentStatus::BANNED, {1, 2});
    search_server.AddDocument(6, "nasty rat with curly hair"sv,  DocumentStatus::BANNED, {1, 2});

в  базу  данных  поисковика  добавляется  документ  с  текстом  "nasty  dog with
big  eyes"  под идентификатором  1 в  статусе ACTUAL с рейтингами {1,2}, которые
будут  внутренне  преобразованы  в  рейтинг  1.5.  После  завершения регистрации
всех  документов  можно  переходить к следующему этапу - собственно, поиску.

### Третий этап.

  Поиск    соответствующих    запросу     документов     выполняется     методом
FindTopDocuments    класса    SearchServer.    Метод    перегружен    для   двух
разновидностей    запросов.    Общим    параметром    всех   запросов   является
собственно                текст                запроса                raw_query.
Он  содержит  искомые  в  документах  разделённые  пробелом слова. Будут найдены
и  могут  попасть  в  результаты  поиска  любые  документы,  содержащие  хотя бы
одно из слов запроса.

  Стоп-слова,    заданные    при     создании     поискового    объекта-сервера,
отбрасываются.   Их  наличие  в  запросах  или  документах  игнорируется,  поиск
производится так, будто ни в запросах, ни в документах их нет.

  Запросы  поддерживают  также  механизм  минус-слов.  Таким  словом  становится
любое   слово   из   запроса,   предварённое   знаком   "минус".   Слово  должно
следовать  сразу  за  знаком  "минус"  без  пробела или иных разделителей. Любой
документ,  содержащий  хотя  бы  одно  минус-слово,  исключается  из поиска и не
будет найден вне зависимости от остальных условий.

  Поисковая  функция-член  FindTopDocuments   возвращает   результаты  поиска  в
виде  вектора  описателей  найденных  документов  типа  Document. Если найденных
документов  слишком  много,  то  возвращаются  не  все  найденные  документы,  а
только   первые   N,   где   N  ==  result_document_count  -  второму  параметру
конструктора   поискового  сервера.  Это  значение  может  быть  также  изменено
специальным методом, описанным ниже.

Перегрузка

    std::vector<Document> FindTopDocuments(const std::string_view raw_query, DocumentStatus demand_status = DocumentStatus::ACTUAL) const;

позволяет   искать   только   те  документы,  которые  имеют  требуемый  статус.
Остальные документы исключаются из поиска.

Перегрузка

    std::vector<Document> FindTopDocuments(const std::string_view raw_query, FilterPred filter_pred) const;

ищет    только    документы,    для    которых   предикат-аргумент   filter_pred
возвращает   истинное   значение.   В   качестве  такого  предиката  может  быть
передан любой вызываемый объект, удовлетворяющий следующей декларации:

    bool filter_pred(int document_id, DocumentStatus status, int rating);

  В   функциональный   объект-предикат    передаются    идентификатор   текущего
найденного  документа,  его  статус  и  средний  усечённый  до  целого  рейтинг.
Передаваемым    аргументом    может    быть    подходящая   свободная   функция,
лямбда-функция или объект-функтор, содержащий соответствующий оператор.

Две перегрузки

    std::vector<Document> FindTopDocuments(ExecutionPolicy&& policy, const std::string_view raw_query, DocumentStatus demand_status = DocumentStatus::ACTUAL) const;

и

    std::vector<Document> FindTopDocuments(ExecutionPolicy&& policy, const std::string_view raw_query, FilterPred filter_pred) const;

обеспечивают    выполнение    тех    же    запросов,    но    позволяют    также
распараллелить     их     выполнение,     указав    соответствующую    стратегию
параллелизма  policy.  Это  позволяет  сильно  ускорить  выполнение программы на
многоядерных              или             многопроцессорных             машинах.
Аргумент   policy   имеет  те  же  возможные  значения,  что  и  соответствующий
аргумент   параллельных   версий  функций  стандартной  библиотеки  C++  STL  из
раздела \<algorithm>.

### Вспомогательные и дополнительные методы класса SearchServer.

  Метод      GetDocumentCount      возвращает       количество       документов,
зарегистрированных в базе поисковика на данный момент.

  Метод  RemoveDocument  удаляет   из   базы   данных   документ   с   указанным
идентификатором.

  Метод    GetSetResultDocumentCount   позволяет    получить    либо    изменить
максимальное  количество  N  найденных  документов,  возвращаемых  в результатах
поиска   функциями   FindTopDocuments.  Если  аргумент  функции  будет  являться
отрицательным  числом,  функция  вернёт  текущее  значение  N,  не  изменяя его.
В   случае   же,   если   аргумент  будет  числом  неотрицательным,  то  функция
установит N равным своему аргументу и вернёт его прежнее значение.

#### Матчировка документа.

  Ещё  одной  вспомогательной   операцией   является   матчировка   документа  -
проверка     соответствия     определённого     документа,    заданного    своим
идентификатором,   определённому   запросу.   Матчировка   выполняется   методом
MatchDocument. Он имеет две перегрузки:

    tuple<vector<string_view>, DocumentStatus> MatchDocument(string_view raw_query, int document_id) const;

    tuple<vector<string_view>, DocumentStatus> MatchDocument(_ExecutionPolicy&& policy, string_view raw_query, int document_id) const;

  Отличаются  они  только   тем,   что   вторая   перегрузка  приспособлена  для
выполнения   операции   параллельно,   в   несколько   потоков,   для   чего  ей
передаётся  параметр  стратегии  параллельности  policy.  В  остальном параметры
функций        и        выполняемая        ими        операция       одинаковая.
Одним    из   параметров   является   непосредственно   запрос,   а   вторым   -
идентификатором документа для матчировки.

  Результатом  матчировки  является   кортеж,   состоящий   из  двух  элементов:
массив  слов  запроса,  которые  наличествуют  в  рассматриваемом  документе,  и
его   статус.  При  матчировке  выполняются  все  правила  поиска  -  стоп-слова
игнорируются,  а  наличие  в  документе  хотя  бы  одного минус-слова из запроса
приводит   к   тому,   что  первым  элементом  кортежа  будет  возвращён  пустой
массив.

#### Получение сведений о документах из базы данных поисковой системы.

  Есть   также   возможность    получить    сведения    обо   всех   документах,
добавленных  в  базу  поисковика.  Для  этого  объект  SearchServer поддерживает
итераторы,   указывающие   на   какие-либо  документы  базы,  при  разыменовании
которых получаются данные типа SearchServer::DocumentData.

    struct DocumentData
    {
        int rating; // Рейтинг документа, рассчитанный на основании массива
                    // входных рейтингов.
        DocumentStatus status; // Статус документа.
        map<string_view, double> word_freqs; //Список слов документа и их
                                             // обратных частот.
    };

  Для  получения  итератора  среди  публичных  методов  SearchServer  существуют
функции   со   стандартными   именами   begin()   и   end().   Функция   begin()
возвращает   итератор,  соответствующий  первому  элементу,  зарегистрированному
в   поисковике,  а  функция  end()  -  итератор,  указывающий  за  конец  списка
документов.   Полученные   итераторы   являются   двунаправленными   и  для  них
определены операторы ++, -- и *.

  Наличие   такого   комплекта   функций   и   операторов   обеспечивает   также
работоспособность    обычного    диапазонного   цикла    for    (   :   )   C++.
Поэтому перебор всех имеющихся документов можно осуществить и так:

    for (Searchserver::DocumentData doc_data : serach_server)
    {
        ....................................................
    }


Обработка ошибок поиска.
------------------------

  Сообщения    об    ошибках     и     недопустимых     ситуациях     передаются
программе-клиенту,   использующей   поисковик,   с   помощью   исключений.   Все
методы   класса   SearchServer   могут  выбрасывать  довольно  широкий  перечень
исключений.

Ограничения и планы развития.
-----------------------------

  Пока  данный  поисковик   представляет   скорее  черновик,  чем  действительно
полезный   продукт.   И  основной  его  недостаток  заключается  в  том,  что  в
документах  ищутся  только  в  точности  те  слова, которые указаны в запросе, в
точности  в  том  же  написании  и  в  той  же грамматической форме. Т. е. чтобы
слово  было  найдено,  в  запросе  оно  должно быть указано буквально также, как
и   документе,  с  полным  добуквенным  совпадением.  Понятно,  что  для  поиска
текстов   на  естественном  языке  такой  алгоритм  подходит  плохо  и  вряд  ли
обеспечит хорошие результаты.

  Поэтому  отсюда  возникает   главное   направление   дальнейшей   доработки  -
возможность   искать  документы  со  словами  запроса  в  других  грамматических
формах   и  в  несколько  отличающемся  написании.  Это  может  быть  достигнуто
автоматическим  преобразованием  запроса  с  добавлением  в  него всех возможных
словоформ  для  всех  входящих  в  него  слов.  Именно такую доработку и следует
попытаться сделать в первую очередь.
